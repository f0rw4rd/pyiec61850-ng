# EXPERIMENTAL: Test Windows wheel build for pyiec61850-ng
#
# This workflow validates that libiec61850 + SWIG Python bindings can compile
# on Windows with MSVC. It does NOT release or publish anything.
#
# The Linux build produces a universal .so that works across Python versions,
# but Windows .pyd files link to version-specific pythonXY.dll, so we need
# one build per Python version.
#
# Status: experimental — expect failures, this is for feasibility testing.

name: Test Windows Build (experimental)

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  LIBIEC61850_PINNED_SHA: '519b0208cc79d1af09d5ca40fb9ad1fd93822e93'
  MBEDTLS_SHA256: '32c500e73ee878e193e7d66bf5e4c34fb42bb968a6c9f9488aa466b16f6f3bff'
  NPCAP_SDK_SHA256: 'f0a8be7778ee3ae1b99bbbecb27a3ff0f6c111a4093f1c78c5c5a099607184db'

jobs:
  build-windows:
    name: Windows build (Python 3.12)
    runs-on: windows-2022
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Python 3.12
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065  # v5
        with:
          python-version: "3.12"

      # MSVC environment is needed for CMake to find the compiler.
      # windows-2022 has MSVC 2022 (v143) pre-installed.
      - name: Activate MSVC developer environment
        uses: ilammy/msvc-dev-cmd@0b201ec74fa43914dc39ae48a89fd1d8cb592756  # v1.13.0

      - name: Show tool versions
        run: |
          Write-Host "=== Python ==="
          python --version
          python -c "import sysconfig; print('Include:', sysconfig.get_path('include')); print('Libs:', sysconfig.get_config_var('LIBDIR') or 'N/A')"

          Write-Host "=== CMake ==="
          cmake --version

          Write-Host "=== SWIG ==="
          swig -version

          Write-Host "=== MSVC ==="
          cl 2>&1 | Select-Object -First 3

      - name: Clone libiec61850 v1.6.0
        run: |
          git clone --depth 50 --branch v1.6.0 https://github.com/mz-automation/libiec61850.git
          cd libiec61850
          $actual_sha = git rev-parse HEAD
          if ($actual_sha -ne "${{ env.LIBIEC61850_PINNED_SHA }}") {
            Write-Error "SHA mismatch! Expected ${{ env.LIBIEC61850_PINNED_SHA }}, got $actual_sha"
            exit 1
          }
          Write-Host "Verified: libiec61850 commit SHA matches pinned value"

      - name: Download and extract mbedTLS v3.6.0
        run: |
          $mbedtls_dir = "libiec61850/third_party/mbedtls"
          $tarball = "$mbedtls_dir/v3.6.0.tar.gz"

          # Download
          Invoke-WebRequest -Uri "https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/v3.6.0.tar.gz" -OutFile $tarball

          # Verify SHA256
          $hash = (Get-FileHash -Path $tarball -Algorithm SHA256).Hash.ToLower()
          if ($hash -ne "${{ env.MBEDTLS_SHA256 }}") {
            Write-Error "mbedTLS SHA256 mismatch! Expected ${{ env.MBEDTLS_SHA256 }}, got $hash"
            exit 1
          }
          Write-Host "mbedTLS checksum verified"

          # Extract
          tar -xzf $tarball -C $mbedtls_dir
          Get-ChildItem $mbedtls_dir

      - name: Apply SWIG interface patch
        shell: bash
        run: |
          # Find the iec61850.i file in the cloned repo (same approach as Dockerfile)
          IEC_FILE=$(find libiec61850 -name "iec61850.i")
          if [ -z "$IEC_FILE" ]; then
            echo "ERROR: Could not find iec61850.i in libiec61850"
            exit 1
          fi
          echo "Found SWIG file: $IEC_FILE"

          # Apply patch (using bash shell — Git for Windows includes patch)
          patch -p1 "$IEC_FILE" < patches/iec61850.i.patch
          echo "Patch applied successfully"

      - name: Download Npcap SDK
        run: |
          # Npcap SDK provides WinPcap-compatible headers and import libs.
          # Only needed for compilation — no driver install required on CI.
          Invoke-WebRequest -Uri "https://npcap.com/dist/npcap-sdk-1.16.zip" -OutFile npcap-sdk.zip

          # Verify integrity
          $hash = (Get-FileHash -Path npcap-sdk.zip -Algorithm SHA256).Hash.ToLower()
          if ($hash -ne "${{ env.NPCAP_SDK_SHA256 }}") {
            Write-Error "Npcap SDK SHA256 mismatch! Expected ${{ env.NPCAP_SDK_SHA256 }}, got $hash"
            exit 1
          }
          Write-Host "Npcap SDK checksum verified"

          Expand-Archive -Path npcap-sdk.zip -DestinationPath npcap-sdk-temp

          # libiec61850 expects third_party/winpcap/{Include,Lib}
          $winpcapDir = "libiec61850/third_party/winpcap"
          New-Item -ItemType Directory -Force -Path "$winpcapDir/Include" | Out-Null
          New-Item -ItemType Directory -Force -Path "$winpcapDir/Lib" | Out-Null

          Copy-Item -Path "npcap-sdk-temp/Include/*" -Destination "$winpcapDir/Include/" -Recurse -Force
          # Use x64 libs (README says: replace Lib files with Lib/x64 on 64-bit)
          Copy-Item -Path "npcap-sdk-temp/Lib/x64/*" -Destination "$winpcapDir/Lib/" -Force

          Write-Host "Npcap SDK installed:"
          Get-ChildItem "$winpcapDir/Include" | ForEach-Object { Write-Host "  Include/$($_.Name)" }
          Get-ChildItem "$winpcapDir/Lib" | ForEach-Object { Write-Host "  Lib/$($_.Name)" }

      - name: Fix missing symbol for Windows
        shell: bash
        run: |
          # IedServer_ignoreClientRequests is declared without LIB61850_API in v1.6.0.
          # On MSVC, .c files are compiled as C++ (set_source_files_properties LANGUAGE CXX).
          # The header's extern "C" covers the declaration, but somehow this one symbol
          # doesn't resolve. All other IedServer_* functions (with LIB61850_API) work fine.
          # Fix: add a stub .c compiled as part of the SWIG module.
          cat > libiec61850/pyiec61850/win32_stubs.c << 'STUB'
          #include <stdbool.h>
          typedef struct sIedServer* IedServer;
          void IedServer_ignoreClientRequests(IedServer self, bool enable) {
              (void)self; (void)enable;
          }
          STUB

          # Add the stub to the SWIG module sources
          sed -i '/SOURCES iec61850.i/s|$|\n    win32_stubs.c|' \
            libiec61850/pyiec61850/CMakeLists.txt

      - name: Configure CMake
        run: |
          mkdir libiec61850/build
          cd libiec61850/build

          # libiec61850's CMakeLists.txt uses find_package(Python), not find_package(Python3).
          # The runner has multiple Python versions pre-installed. We force the correct one
          # by setting Python_ROOT_DIR and putting our Python first on PATH.
          $python_root = Split-Path (Get-Command python).Source
          $python_exe = (Get-Command python).Source

          Write-Host "Python root: $python_root"
          Write-Host "Python executable: $python_exe"
          python --version

          # Prepend our Python to PATH so CMake finds it first.
          # Add Python libs dir to LIB so the MSVC linker finds pythonXY.lib.
          # NMake generator doesn't propagate FindPython's library path to link.exe.
          $python_libs = Join-Path $python_root "libs"
          $env:PATH = "$python_root;$env:PATH"
          $env:LIB = "$python_libs;$env:LIB"
          Write-Host "Added to LIB: $python_libs"

          # Persist for subsequent steps (each run: block is a new shell)
          "LIB=$python_libs;$env:LIB" >> $env:GITHUB_ENV

          cmake .. `
            -DBUILD_PYTHON_BINDINGS=ON `
            -DCMAKE_BUILD_TYPE=Release `
            -DPython_ROOT_DIR="$python_root" `
            -DPython_FIND_STRATEGY=LOCATION `
            -G "NMake Makefiles"

      - name: Build
        run: |
          cd libiec61850/build
          nmake

      - name: List build outputs
        run: |
          Write-Host "=== Full build tree (DLLs, PYDs, LIBs) ==="
          Get-ChildItem -Path libiec61850/build -Recurse -Include *.dll,*.pyd,*.lib,*.exp,*.so,*.py |
            ForEach-Object { Write-Host $_.FullName }

          Write-Host ""
          Write-Host "=== Python bindings directory ==="
          $pydir = "libiec61850/build/pyiec61850"
          if (Test-Path $pydir) {
            Get-ChildItem -Path $pydir -Recurse | ForEach-Object { Write-Host "$($_.Length)`t$($_.FullName)" }
          } else {
            Write-Host "pyiec61850 build directory not found — checking alternative locations..."
            Get-ChildItem -Path libiec61850/build -Recurse -Filter "*pyiec61850*" |
              ForEach-Object { Write-Host $_.FullName }
          }

          Write-Host ""
          Write-Host "=== Main library ==="
          Get-ChildItem -Path libiec61850/build -Recurse -Filter "iec61850*" -Include *.dll,*.lib |
            ForEach-Object { Write-Host "$($_.Length)`t$($_.FullName)" }

      - name: Test import
        run: |
          $pydir = "libiec61850/build/pyiec61850"

          # The build should produce _pyiec61850.pyd and pyiec61850.py (SWIG wrapper).
          # We also need the main iec61850.dll on PATH or in the same directory.

          # Find and copy the main DLL next to the .pyd so it can be loaded
          $main_dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter "iec61850.dll" | Select-Object -First 1
          if ($main_dll) {
            Copy-Item $main_dll.FullName -Destination $pydir/ -ErrorAction SilentlyContinue
            Write-Host "Copied $($main_dll.Name) to $pydir"
          }

          # Also try libiec61850.dll
          $lib_dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter "libiec61850.dll" | Select-Object -First 1
          if ($lib_dll) {
            Copy-Item $lib_dll.FullName -Destination $pydir/ -ErrorAction SilentlyContinue
            Write-Host "Copied $($lib_dll.Name) to $pydir"
          }

          # List what we have
          Write-Host "=== Files in $pydir ==="
          Get-ChildItem $pydir -ErrorAction SilentlyContinue |
            ForEach-Object { Write-Host "$($_.Length)`t$($_.Name)" }

          # Attempt the import
          Write-Host ""
          Write-Host "=== Testing Python import ==="
          $env:PYTHONPATH = "$pydir;$env:PYTHONPATH"
          python -c @"
          import sys, os
          print(f'Python {sys.version}')
          print(f'PYTHONPATH: {os.environ.get("PYTHONPATH", "not set")}')
          try:
              import pyiec61850
              print('SUCCESS: pyiec61850 SWIG bindings imported')
              # Try a simple attribute access to verify the module is functional
              print(f'Module file: {pyiec61850.__file__}')
          except ImportError as e:
              print(f'IMPORT ERROR: {e}')
              # This is expected to fail on first attempts — that's what we're testing
              sys.exit(1)
          except Exception as e:
              print(f'OTHER ERROR: {type(e).__name__}: {e}')
              sys.exit(1)
          "@

      - name: Collect build artifacts
        if: always()
        run: |
          $out = "windows-build-output"
          New-Item -ItemType Directory -Force -Path $out | Out-Null

          # Copy everything potentially useful from the build
          $extensions = @("*.pyd", "*.dll", "*.lib", "*.py")
          foreach ($ext in $extensions) {
            Get-ChildItem -Path libiec61850/build -Recurse -Filter $ext |
              Where-Object { $_.DirectoryName -notmatch "CMakeFiles" } |
              ForEach-Object {
                # Flatten into output dir with path info in filename
                $relative = $_.FullName.Replace("$PWD\libiec61850\build\", "").Replace("\", "_")
                Copy-Item $_.FullName -Destination "$out/$relative" -ErrorAction SilentlyContinue
              }
          }

          # Also grab CMake cache for debugging
          Copy-Item libiec61850/build/CMakeCache.txt -Destination "$out/" -ErrorAction SilentlyContinue

          Write-Host "=== Collected artifacts ==="
          Get-ChildItem $out | ForEach-Object { Write-Host "$($_.Length)`t$($_.Name)" }

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: windows-build-py3.12
          path: windows-build-output/
          retention-days: 14
