# EXPERIMENTAL: Test Windows wheel build for pyiec61850-ng
#
# This workflow validates that libiec61850 + SWIG Python bindings can compile
# on Windows with MSVC. It does NOT release or publish anything.
#
# The Linux build produces a universal .so that works across Python versions,
# but Windows .pyd files link to version-specific pythonXY.dll, so we need
# one build per Python version.
#
# Status: experimental — expect failures, this is for feasibility testing.

name: Test Windows Build (experimental)

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  LIBIEC61850_PINNED_SHA: '519b0208cc79d1af09d5ca40fb9ad1fd93822e93'
  MBEDTLS_SHA256: '32c500e73ee878e193e7d66bf5e4c34fb42bb968a6c9f9488aa466b16f6f3bff'
  NPCAP_SDK_SHA256: 'f0a8be7778ee3ae1b99bbbecb27a3ff0f6c111a4093f1c78c5c5a099607184db'

jobs:
  build-windows:
    name: Windows build (Python 3.12)
    runs-on: windows-2022
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Python 3.12
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065  # v5
        with:
          python-version: "3.12"

      # MSVC environment is needed for CMake to find the compiler.
      # windows-2022 has MSVC 2022 (v143) pre-installed.
      - name: Activate MSVC developer environment
        uses: ilammy/msvc-dev-cmd@0b201ec74fa43914dc39ae48a89fd1d8cb592756  # v1.13.0

      - name: Show tool versions
        run: |
          Write-Host "=== Python ==="
          python --version
          python -c "import sysconfig; print('Include:', sysconfig.get_path('include')); print('Libs:', sysconfig.get_config_var('LIBDIR') or 'N/A')"

          Write-Host "=== CMake ==="
          cmake --version

          Write-Host "=== SWIG ==="
          swig -version

          Write-Host "=== MSVC ==="
          cl 2>&1 | Select-Object -First 3

      - name: Clone libiec61850 v1.6.0
        run: |
          git clone --depth 50 --branch v1.6.0 https://github.com/mz-automation/libiec61850.git
          cd libiec61850
          $actual_sha = git rev-parse HEAD
          if ($actual_sha -ne "${{ env.LIBIEC61850_PINNED_SHA }}") {
            Write-Error "SHA mismatch! Expected ${{ env.LIBIEC61850_PINNED_SHA }}, got $actual_sha"
            exit 1
          }
          Write-Host "Verified: libiec61850 commit SHA matches pinned value"

      - name: Download and extract mbedTLS v3.6.0
        run: |
          $mbedtls_dir = "libiec61850/third_party/mbedtls"
          $tarball = "$mbedtls_dir/v3.6.0.tar.gz"

          # Download
          Invoke-WebRequest -Uri "https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/v3.6.0.tar.gz" -OutFile $tarball

          # Verify SHA256
          $hash = (Get-FileHash -Path $tarball -Algorithm SHA256).Hash.ToLower()
          if ($hash -ne "${{ env.MBEDTLS_SHA256 }}") {
            Write-Error "mbedTLS SHA256 mismatch! Expected ${{ env.MBEDTLS_SHA256 }}, got $hash"
            exit 1
          }
          Write-Host "mbedTLS checksum verified"

          # Extract
          tar -xzf $tarball -C $mbedtls_dir
          Get-ChildItem $mbedtls_dir

      - name: Apply SWIG interface patch
        shell: bash
        run: |
          # Find the iec61850.i file in the cloned repo (same approach as Dockerfile)
          IEC_FILE=$(find libiec61850 -name "iec61850.i")
          if [ -z "$IEC_FILE" ]; then
            echo "ERROR: Could not find iec61850.i in libiec61850"
            exit 1
          fi
          echo "Found SWIG file: $IEC_FILE"

          # Apply patch (using bash shell — Git for Windows includes patch)
          patch -p1 "$IEC_FILE" < patches/iec61850.i.patch
          echo "Patch applied successfully"

      - name: Download Npcap SDK
        run: |
          # Npcap SDK provides WinPcap-compatible headers and import libs.
          # Only needed for compilation — no driver install required on CI.
          Invoke-WebRequest -Uri "https://npcap.com/dist/npcap-sdk-1.16.zip" -OutFile npcap-sdk.zip

          # Verify integrity
          $hash = (Get-FileHash -Path npcap-sdk.zip -Algorithm SHA256).Hash.ToLower()
          if ($hash -ne "${{ env.NPCAP_SDK_SHA256 }}") {
            Write-Error "Npcap SDK SHA256 mismatch! Expected ${{ env.NPCAP_SDK_SHA256 }}, got $hash"
            exit 1
          }
          Write-Host "Npcap SDK checksum verified"

          Expand-Archive -Path npcap-sdk.zip -DestinationPath npcap-sdk-temp

          # libiec61850 expects third_party/winpcap/{Include,Lib}
          $winpcapDir = "libiec61850/third_party/winpcap"
          New-Item -ItemType Directory -Force -Path "$winpcapDir/Include" | Out-Null
          New-Item -ItemType Directory -Force -Path "$winpcapDir/Lib" | Out-Null

          Copy-Item -Path "npcap-sdk-temp/Include/*" -Destination "$winpcapDir/Include/" -Recurse -Force
          # Use x64 libs (README says: replace Lib files with Lib/x64 on 64-bit)
          Copy-Item -Path "npcap-sdk-temp/Lib/x64/*" -Destination "$winpcapDir/Lib/" -Force

          Write-Host "Npcap SDK installed:"
          Get-ChildItem "$winpcapDir/Include" | ForEach-Object { Write-Host "  Include/$($_.Name)" }
          Get-ChildItem "$winpcapDir/Lib" | ForEach-Object { Write-Host "  Lib/$($_.Name)" }

      - name: Fix missing symbol for Windows
        shell: bash
        run: |
          # IedServer_ignoreClientRequests is declared without LIB61850_API in v1.6.0.
          # On MSVC, .c files are compiled as C++ (set_source_files_properties LANGUAGE CXX).
          # The header's extern "C" covers the declaration, but somehow this one symbol
          # doesn't resolve. All other IedServer_* functions (with LIB61850_API) work fine.
          # Fix: add a stub .c compiled as part of the SWIG module.
          cat > libiec61850/pyiec61850/win32_stubs.c << 'STUB'
          #include <stdbool.h>
          typedef struct sIedServer* IedServer;
          void IedServer_ignoreClientRequests(IedServer self, bool enable) {
              (void)self; (void)enable;
          }
          STUB

          # Add the stub to the SWIG module sources
          sed -i '/SOURCES iec61850.i/s|$|\n    win32_stubs.c|' \
            libiec61850/pyiec61850/CMakeLists.txt

      - name: Configure CMake
        run: |
          mkdir libiec61850/build
          cd libiec61850/build

          # libiec61850's CMakeLists.txt uses find_package(Python), not find_package(Python3).
          # The runner has multiple Python versions pre-installed. We force the correct one
          # by setting Python_ROOT_DIR and putting our Python first on PATH.
          $python_root = Split-Path (Get-Command python).Source
          $python_exe = (Get-Command python).Source

          Write-Host "Python root: $python_root"
          Write-Host "Python executable: $python_exe"
          python --version

          # Prepend our Python to PATH so CMake finds it first.
          # Add Python libs dir to LIB so the MSVC linker finds pythonXY.lib.
          # NMake generator doesn't propagate FindPython's library path to link.exe.
          $python_libs = Join-Path $python_root "libs"
          $env:PATH = "$python_root;$env:PATH"
          $env:LIB = "$python_libs;$env:LIB"
          Write-Host "Added to LIB: $python_libs"

          # Persist for subsequent steps (each run: block is a new shell)
          "LIB=$python_libs;$env:LIB" >> $env:GITHUB_ENV

          cmake .. `
            -DBUILD_PYTHON_BINDINGS=ON `
            -DCMAKE_BUILD_TYPE=Release `
            -DPython_ROOT_DIR="$python_root" `
            -DPython_FIND_STRATEGY=LOCATION `
            -G "NMake Makefiles"

      - name: Build
        run: |
          cd libiec61850/build
          nmake

      - name: List build outputs
        run: |
          Write-Host "=== Full build tree (DLLs, PYDs, LIBs) ==="
          Get-ChildItem -Path libiec61850/build -Recurse -Include *.dll,*.pyd,*.lib,*.exp,*.so,*.py |
            ForEach-Object { Write-Host $_.FullName }

          Write-Host ""
          Write-Host "=== Python bindings directory ==="
          $pydir = "libiec61850/build/pyiec61850"
          if (Test-Path $pydir) {
            Get-ChildItem -Path $pydir -Recurse | ForEach-Object { Write-Host "$($_.Length)`t$($_.FullName)" }
          } else {
            Write-Host "pyiec61850 build directory not found — checking alternative locations..."
            Get-ChildItem -Path libiec61850/build -Recurse -Filter "*pyiec61850*" |
              ForEach-Object { Write-Host $_.FullName }
          }

          Write-Host ""
          Write-Host "=== Main library ==="
          Get-ChildItem -Path libiec61850/build -Recurse -Filter "iec61850*" -Include *.dll,*.lib |
            ForEach-Object { Write-Host "$($_.Length)`t$($_.FullName)" }

      - name: Test import
        run: |
          $pydir = "libiec61850/build/pyiec61850"

          # The build should produce _pyiec61850.pyd and pyiec61850.py (SWIG wrapper).
          # We also need the main iec61850.dll on PATH or in the same directory.

          # Find and copy the main DLL next to the .pyd so it can be loaded
          $main_dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter "iec61850.dll" | Select-Object -First 1
          if ($main_dll) {
            Copy-Item $main_dll.FullName -Destination $pydir/ -ErrorAction SilentlyContinue
            Write-Host "Copied $($main_dll.Name) to $pydir"
          }

          # Also try libiec61850.dll
          $lib_dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter "libiec61850.dll" | Select-Object -First 1
          if ($lib_dll) {
            Copy-Item $lib_dll.FullName -Destination $pydir/ -ErrorAction SilentlyContinue
            Write-Host "Copied $($lib_dll.Name) to $pydir"
          }

          # List what we have
          Write-Host "=== Files in $pydir ==="
          Get-ChildItem $pydir -ErrorAction SilentlyContinue |
            ForEach-Object { Write-Host "$($_.Length)`t$($_.Name)" }

          # Attempt the import
          Write-Host ""
          Write-Host "=== Testing Python import ==="
          $env:PYTHONPATH = "$pydir;$env:PYTHONPATH"
          python -c @"
          import sys, os
          print(f'Python {sys.version}')
          print(f'PYTHONPATH: {os.environ.get("PYTHONPATH", "not set")}')
          try:
              import pyiec61850
              print('SUCCESS: pyiec61850 SWIG bindings imported')
              # Try a simple attribute access to verify the module is functional
              print(f'Module file: {pyiec61850.__file__}')
          except ImportError as e:
              print(f'IMPORT ERROR: {e}')
              # This is expected to fail on first attempts — that's what we're testing
              sys.exit(1)
          except Exception as e:
              print(f'OTHER ERROR: {type(e).__name__}: {e}')
              sys.exit(1)
          "@

      - name: Package wheel
        run: |
          $pydir = "libiec61850/build/pyiec61850"
          $staging = "wheel-staging"
          $pkgdir = "$staging/pyiec61850"

          # Create package directory
          New-Item -ItemType Directory -Force -Path $pkgdir | Out-Null

          # Copy SWIG build outputs
          Copy-Item "$pydir/_pyiec61850.pyd" -Destination $pkgdir/
          Copy-Item "$pydir/pyiec61850.py" -Destination $pkgdir/

          # Copy DLLs the .pyd may need at runtime
          foreach ($pattern in @("iec61850.dll", "libiec61850.dll")) {
            $dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter $pattern |
              Select-Object -First 1
            if ($dll) {
              Copy-Item $dll.FullName -Destination $pkgdir/
              Write-Host "Included: $($dll.Name)"
            }
          }

          # Create __init__.py with Windows DLL loader
          $initContent = @'
          import os, sys, ctypes
          _package_dir = os.path.dirname(os.path.abspath(__file__))
          _dll_dir_handle = None
          if sys.platform == 'win32':
              if hasattr(os, 'add_dll_directory'):
                  _dll_dir_handle = os.add_dll_directory(_package_dir)
              os.environ['PATH'] = _package_dir + os.pathsep + os.environ.get('PATH', '')
              for _f in sorted(os.listdir(_package_dir)):
                  if _f.endswith('.dll') and 'iec61850' in _f.lower():
                      try:
                          ctypes.WinDLL(os.path.join(_package_dir, _f), winmode=0)
                          break
                      except Exception as _e:
                          print(f'Warning: Failed to load {_f}: {_e}')
          else:
              for _f in os.listdir(_package_dir):
                  if _f.startswith('libiec61850.so'):
                      try:
                          ctypes.CDLL(os.path.join(_package_dir, _f))
                          break
                      except Exception:
                          pass
          '@
          Set-Content -Path "$pkgdir/__init__.py" -Value $initContent -Encoding utf8

          # Copy project metadata
          Copy-Item LICENSE -Destination $staging/
          Copy-Item NOTICE -Destination $staging/
          Copy-Item README.md -Destination $staging/

          # Create Windows-specific setup.py (package_data differs from Linux)
          $setupContent = @'
          import os
          from setuptools import setup, find_packages
          from setuptools.dist import Distribution
          version = os.environ.get('PACKAGE_VERSION', '1.6.0.9')
          class BinaryDistribution(Distribution):
              def has_ext_modules(self):
                  return True
          setup(
              name='pyiec61850-ng',
              version=version,
              description='Python bindings for libiec61850',
              packages=find_packages(),
              package_data={'pyiec61850': ['*.pyd', '*.dll', '*.py']},
              include_package_data=True,
              distclass=BinaryDistribution,
          )
          '@
          Set-Content -Path "$staging/setup.py" -Value $setupContent -Encoding utf8

          # Get version and build wheel
          $version = python version.py
          Write-Host "Building wheel version: $version"
          pip install setuptools wheel
          Push-Location $staging
          $env:PACKAGE_VERSION = $version
          python setup.py bdist_wheel
          Pop-Location

          # Show result
          Write-Host "=== Built wheel ==="
          Get-ChildItem "$staging/dist/*.whl" | ForEach-Object {
            Write-Host "$($_.Length)`t$($_.Name)"
            python -c "import zipfile,sys;[print(f'  {f.filename}') for f in zipfile.ZipFile(sys.argv[1]).filelist]" $_.FullName
          }

      - name: Show DLL dependencies
        run: |
          Write-Host "=== _pyiec61850.pyd dependencies ==="
          dumpbin /dependents libiec61850/build/pyiec61850/_pyiec61850.pyd 2>&1 |
            Select-String -Pattern "\.dll" -CaseSensitive:$false
          $iec_dll = Get-ChildItem -Path libiec61850/build -Recurse -Filter "iec61850.dll" | Select-Object -First 1
          if ($iec_dll) {
            Write-Host ""
            Write-Host "=== iec61850.dll dependencies ==="
            dumpbin /dependents $iec_dll.FullName 2>&1 |
              Select-String -Pattern "\.dll" -CaseSensitive:$false
          }

      - name: Test wheel install
        run: |
          python -m venv test-venv
          $wheel = (Get-ChildItem "wheel-staging/dist/*.whl")[0]
          Write-Host "Installing: $($wheel.Name)"

          & test-venv/Scripts/pip.exe install $wheel.FullName

          # Run import test from a temp directory to avoid the repo's pyiec61850/
          # directory shadowing the installed wheel (CWD is on sys.path).
          $venvPython = (Resolve-Path "test-venv/Scripts/python.exe").Path
          Push-Location $env:TEMP
          Write-Host "=== Testing import from installed wheel ==="
          & $venvPython -c @'
          import pyiec61850
          print(f'Package dir: {pyiec61850._package_dir}')
          from pyiec61850 import pyiec61850 as swig_mod
          print(f'SWIG module: {swig_mod.__file__}')
          print('SUCCESS: Wheel import works')
          '@
          Pop-Location

      - name: Collect build artifacts
        if: always()
        run: |
          $out = "windows-build-output"
          New-Item -ItemType Directory -Force -Path $out | Out-Null

          # Copy everything potentially useful from the build
          $extensions = @("*.pyd", "*.dll", "*.lib", "*.py")
          foreach ($ext in $extensions) {
            Get-ChildItem -Path libiec61850/build -Recurse -Filter $ext |
              Where-Object { $_.DirectoryName -notmatch "CMakeFiles" } |
              ForEach-Object {
                # Flatten into output dir with path info in filename
                $relative = $_.FullName.Replace("$PWD\libiec61850\build\", "").Replace("\", "_")
                Copy-Item $_.FullName -Destination "$out/$relative" -ErrorAction SilentlyContinue
              }
          }

          # Also grab CMake cache for debugging
          Copy-Item libiec61850/build/CMakeCache.txt -Destination "$out/" -ErrorAction SilentlyContinue

          Write-Host "=== Collected artifacts ==="
          Get-ChildItem $out | ForEach-Object { Write-Host "$($_.Length)`t$($_.Name)" }

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: windows-build-py3.12
          path: windows-build-output/
          retention-days: 14

      - name: Upload wheel
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: windows-wheel-py3.12
          path: wheel-staging/dist/*.whl
          if-no-files-found: warn
          retention-days: 14
